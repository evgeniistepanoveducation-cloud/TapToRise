<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>TapToRise</title>
  
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    
    .bg {
      position: fixed;
      inset: 0;
      background-image: url('Gradient_Blue.jpg'); 
      background-size: cover;
      background-position: center;
    }
    
    .wrap {
      position: fixed;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .tap {
      font-size: 48px;
      width: 300px;
      height: 300px;
      border: none;
      border-radius: 50%;
      background-color: #2ea6ff;
      color: #fff;
      cursor: pointer;
      box-shadow: 0 10px 24px rgba(0,0,0,0.3);
      display: flex;
      justify-content: center; 
      align-items: center; 
      touch-action: manipulation;
      user-select: none;
    }
    
    .xp-counter {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.4);
      color: #fff;
      padding: 16px 20px;
      border-radius: 16px;
      font-weight: bold;
      font-size: 32px;
    }

    .level-indicator {
      position: fixed;
      top: 100px;
      left: 20px;
      background: rgba(0,0,0,0.4);
      color: #fff;
      padding: 10px 16px;
      border-radius: 12px;
      font-weight: bold;
      font-size: 20px;
    }

    .xp-bar-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 16px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      overflow: hidden;
      z-index: 100;
    }

    .xp-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #ffd700, #ff8c00);
      transition: width 0.3s ease-out;
    }

    #message {
      display:none;
      position:fixed;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      background:black;
      color:white;
      padding:20px;
      border-radius:10px;
      font-size:20px;
      z-index:2000;
    }

    /* Roulette overlay CSS begins here */
    #rouletteOverlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    #rouletteMask {
  width: 80%;
  max-width: 600px;
  height: 200px;
  background: white;
  border-radius: 16px;
  overflow: hidden;
  position: relative;
  border: 4px solid gold; /* highlight border */
}

#rouletteBox div {
  flex: 0 0 100px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 36px;
  transition: transform 0.2s;
}

#rouletteBox div.highlight {
  transform: scale(1.5);
  color: orange;
}

#rouletteBox {
  display: flex;
  flex-direction: row;
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
}



    /* Roulette overlay CSS ends here */
  </style>
</head>
<body>






  <!-- Background & UI -->
  <div class="bg"></div>
  <div class="xp-bar-container">
    <div class="xp-bar" id="xpBar"></div>
  </div>
  <div class="wrap">
    <button class="tap" id="tapBtn">ðŸ”¥ TAP! ðŸ”¥</button>
  </div>
  <div class="level-indicator" id="levelIndicator">Level: 1</div>
  <div class="xp-counter" id="xpCounter">XP: 0</div>
  <div id="message"></div>

  <!-- Roulette overlay begins here -->
  <div id="rouletteOverlay">
    <div id="rouletteMask">
      <div id="rouletteBox"></div>
    </div>
  </div>
  <!-- Roulette overlay ends here -->









  <!-- JS -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
<!-- REPLACE current spin-related code with this block -->
<script>
/* ---------- spin state & helpers ---------- */
let chosenIndex = 0;
let duplicatesCount = 0;
let totalDivCount = 0;
let position = 0;         // transform X in px (negative moves left)
let speed = 0;
let rafId = null;
let spinning = false;
const prizeCount = prizes.length;
const prizeWidthPx = prizeWidth; // keep name local

function buildStrip(duplicates) {
  rouletteBox.innerHTML = '';
  for (let d = 0; d < duplicates; d++) {
    for (let i = 0; i < prizes.length; i++) {
      const div = document.createElement('div');
      div.textContent = prizes[i];
      rouletteBox.appendChild(div);
    }
  }
  totalDivCount = duplicates * prizes.length;
}

/* RAF spin: constant speed (px/frame) */
function spinLoop() {
  if (!spinning) return;
  position -= speed;
  rouletteBox.style.transform = `translateX(${position}px)`;
  rafId = requestAnimationFrame(spinLoop);
}

/* Finalize: forward-only smooth move to the next occurrence of chosenIndex */
function finalizeToChosen() {
  // stop RAF
  if (rafId) cancelAnimationFrame(rafId);
  rafId = null;
  spinning = false;

  const mask = document.getElementById('rouletteMask');
  const centerOffset = (mask.offsetWidth / 2 - prizeWidthPx / 2);
  const maskWidth = mask.offsetWidth;

  // current floating column at center (may be fractional)
  const currentIndexFloat = (-position + centerOffset) / prizeWidthPx;

  // compute smallest forward targetIdx > currentIndexFloat that matches chosenIndex mod prizeCount
  let k = Math.floor((currentIndexFloat - chosenIndex) / prizeCount) + 1;
  let targetIdx = chosenIndex + k * prizeCount;

  // ensure enough duplicates to reach targetIdx; extend if necessary
  const rightMargin = Math.ceil(maskWidth / prizeWidthPx) + 4;
  if (targetIdx >= totalDivCount - rightMargin) {
    const need = Math.ceil((targetIdx - (totalDivCount - rightMargin) + 1) / prizeCount) + 4;
    duplicatesCount += need;
    buildStrip(duplicatesCount);
    // position visual content unchanged â€” recompute targetIdx relative to same position
    // currentIndexFloat stays valid; recompute k & targetIdx
    const newCurrent = (-position + centerOffset) / prizeWidthPx;
    const newK = Math.floor((newCurrent - chosenIndex) / prizeCount) + 1;
    targetIdx = chosenIndex + newK * prizeCount;
  }

  const targetTranslate = -targetIdx * prizeWidthPx + centerOffset;

  // forward-only final move (no backward)
  rouletteBox.style.transition = 'transform 600ms cubic-bezier(0.22,0.8,0.2,1)';
  requestAnimationFrame(() => {
    rouletteBox.style.transform = `translateX(${targetTranslate}px)`;
  });

  // finalize after transition
  const onEnd = () => {
    rouletteBox.removeEventListener('transitionend', onEnd);

    // highlight the exact DOM element
    const prizeDivs = rouletteBox.querySelectorAll('div');
    prizeDivs.forEach(d => d.classList.remove('highlight'));
    const targetDiv = prizeDivs[targetIdx];
    if (targetDiv) targetDiv.classList.add('highlight');

    const wonPrize = prizes[targetIdx % prizeCount];
    message.textContent = `ðŸŽ‰ You won ${wonPrize}!`;
    message.style.display = 'block';
    setTimeout(() => { message.style.display = 'none'; }, 2000);

    // cleanup
    rouletteOverlay.style.display = 'none';
    tapBtn.disabled = false;
    rouletteTriggered = false;
    rouletteBox.style.transition = 'none';
  };

  rouletteBox.addEventListener('transitionend', onEnd);

  // safety fallback
  setTimeout(() => {
    if (rouletteOverlay.style.display === 'flex') {
      rouletteBox.dispatchEvent(new Event('transitionend'));
    }
  }, 800);
}

/* ---------- startSpin: pre-choose prize, center it, run constant-time spin ---------- */
function startSpin() {
  // 1) choose result BEFORE spin
  chosenIndex = choosePrizeByProbability();

  const mask = document.getElementById('rouletteMask');
  const maskWidth = mask.offsetWidth;
  const centerOffset = (maskWidth / 2 - prizeWidthPx / 2);

  // 2) build a large strip (fixed large loops to avoid running out)
  const loops = 100; // large buffer
  const neededMargin = Math.ceil(maskWidth / prizeWidthPx) + 8;
  duplicatesCount = loops + neededMargin;
  buildStrip(duplicatesCount);

  // 3) compute a startIndex such that the center initially shows the chosenIndex
  // base center index
  const baseCenter = Math.floor(totalDivCount / 2);
  // adjust so baseCenter % prizeCount === chosenIndex
  const mod = ((baseCenter - chosenIndex) % prizeCount + prizeCount) % prizeCount;
  const startIndex = baseCenter - mod; // now startIndex % prizeCount == chosenIndex

  // 4) set position so chosenIndex (at startIndex) is centered
  position = -(startIndex * prizeWidthPx) + centerOffset;
  rouletteBox.style.transition = 'none';
  rouletteBox.style.transform = `translateX(${position}px)`;

  // 5) spin params: constant speed, you can tweak these
  speed = 6;        // px per frame â€” lower for slower debug, raise for faster
  spinning = true;
  rafId = requestAnimationFrame(spinLoop);

  // 6) fixed spin duration (constant)
  const spinDurationMs = 3000; // <- ALWAYS constant spin time (change as needed)
  setTimeout(() => {
    // stop RAF and perform forward-only final move to chosenIndex
    finalizeToChosen();
  }, spinDurationMs);
}
</script>







</body>
</html>
